#!/bin/bash
# bademacs - a micro GNU Emacs (mg) compatible editor as a single shell function
#
# Source this file in your .bashrc:  source /path/to/bademacs
# Then run:  bademacs [filename]
#
# Keybindings (mg/emacs compatible):
#   C-x C-c    quit              C-x C-s    save
#   C-x C-f    find file         C-x C-w    write file (save as)
#   C-x C-x    exchange pt/mark  C-x =      cursor position
#   C-x g      goto line         C-x h      mark whole buffer
#   C-x i      insert file       C-x k      kill buffer
#   C-f/Right  forward char      C-b/Left   backward char
#   C-n/Down   next line         C-p/Up     previous line
#   C-a/Home   begin of line     C-e/End    end of line
#   M-f        forward word      M-b        backward word
#   C-v/PgDn   page down         M-v/PgUp   page up
#   M-<        begin of buffer   M->        end of buffer
#   C-d/Del    delete char       Bksp       delete backward
#   C-k        kill line         C-y        yank
#   C-w        kill region       M-w        copy region
#   C-SPC      set mark          C-t        transpose chars
#   C-o        open line         C-l        recenter
#   M-d        kill word          M-DEL     kill word backward
#   M-u        upcase word       M-l        downcase word
#   M-c        capitalize word   M-%        query replace
#   C-s        search forward    C-r        search backward
#   M-g        goto line         M-x        extended command
#   C-g        cancel            C-z        suspend

bademacs() {
    if (( $# > 1 )); then
        printf 'Usage: bademacs [filename]\n' >&2
        return 1
    fi

    local _f="${1:-*scratch*}" _mod=0 _kill="" _msg="" _cx=0
    local _cl=0 _cc=0 _top=0 _left=0 _gcol=-1
    local _ml=-1 _mc=-1 _mactive=0
    local _rows _cols _erows _running=1 _resized=0
    local _old_stty _mini CSI=$'\e['
    local -a _lines
    _old_stty=$(stty -g)
    _rows=$(tput lines); _cols=$(tput cols); _erows=$((_rows - 2))

    _be_cleanup() {
        printf '%s%s' "${CSI}?25h" "${CSI}?1049l"
        stty "$_old_stty" 2>/dev/null
    }

    _be_load() {
        _lines=()
        if [[ -f "$_f" ]]; then
            while IFS= read -r _ln || [[ -n "$_ln" ]]; do
                _lines+=("${_ln%$'\r'}")
            done < "$_f"
        fi
        (( ${#_lines[@]} == 0 )) && _lines=("")
        _mod=0
    }

    _be_save() {
        if [[ "$_f" == "*scratch*" ]]; then
            _be_write_file; return
        fi
        local _i
        { for ((_i=0; _i<${#_lines[@]}; _i++)); do
            printf '%s\n' "${_lines[$_i]}"
        done; } > "$_f"
        _mod=0
        _msg="Wrote $_f (${#_lines[@]} lines)"
    }

    _be_splice() {
        local _idx=$1 _i; local -a _new=()
        for ((_i=0; _i<${#_lines[@]}; _i++)); do
            (( _i != _idx )) && _new+=("${_lines[$_i]}")
        done
        _lines=("${_new[@]}")
    }

    _be_ins_after() {
        local _idx=$1 _content="$2" _i; local -a _new=()
        for ((_i=0; _i<${#_lines[@]}; _i++)); do
            _new+=("${_lines[$_i]}")
            (( _i == _idx )) && _new+=("$_content")
        done
        _lines=("${_new[@]}")
    }

    _be_clamp() {
        local _n=${#_lines[@]}
        (( _cl >= _n )) && _cl=$((_n - 1))
        (( _cl < 0 )) && _cl=0
        local _len=${#_lines[$_cl]}
        (( _cc > _len )) && _cc=$_len
        (( _cc < 0 )) && _cc=0
        (( _cl < _top )) && _top=$_cl
        (( _cl >= _top + _erows )) && _top=$((_cl - _erows + 1))
        (( _top < 0 )) && _top=0
        (( _cc < _left )) && _left=$_cc
        (( _cc >= _left + _cols )) && _left=$((_cc - _cols + 1))
        (( _left < 0 )) && _left=0
    }

    _be_draw() {
        local _buf="" _row _li _line _pct _mi _sc _st
        _buf+="${CSI}?25l"
        for ((_row=0; _row<_erows; _row++)); do
            _li=$((_top + _row))
            _buf+="${CSI}$((_row+1));1H${CSI}K"
            if (( _li < ${#_lines[@]} )); then
                _line="${_lines[$_li]:$_left:$_cols}"
                _buf+="$_line"
            fi
        done
        (( _mod )) && _mi="**" || _mi="--"
        if (( ${#_lines[@]} <= _erows )); then _pct="All"
        elif (( _top == 0 )); then _pct="Top"
        elif (( _top + _erows >= ${#_lines[@]} )); then _pct="Bot"
        else _pct="$(( _top * 100 / (${#_lines[@]} - _erows) ))%"; fi
        printf -v _st '%-*s' "$_cols" \
            "-${_mi}- bademacs: ${_f}  L$((_cl+1)) C$((_cc+1)) (${_pct})"
        _buf+="${CSI}$((_rows-1));1H${CSI}7m${_st}${CSI}27m"
        _buf+="${CSI}${_rows};1H${CSI}K"
        [[ -n "$_msg" ]] && _buf+="$_msg"
        _msg=""
        _sc=$((_cc - _left + 1))
        (( _sc < 1 )) && _sc=1
        (( _sc > _cols )) && _sc=$_cols
        _buf+="${CSI}$((_cl - _top + 1));${_sc}H${CSI}?25h"
        printf '%s' "$_buf"
    }

    _be_insert_char() {
        local _ch="$1" _line="${_lines[$_cl]}"
        _lines[$_cl]="${_line:0:$_cc}${_ch}${_line:$_cc}"
        (( _cc += ${#_ch} ))
        _mod=1; _gcol=-1
    }

    _be_delete_char() {
        local _line="${_lines[$_cl]}" _len=${#_lines[$_cl]}
        if (( _cc < _len )); then
            _lines[$_cl]="${_line:0:$_cc}${_line:$((_cc+1))}"
            _mod=1
        elif (( _cl < ${#_lines[@]} - 1 )); then
            _lines[$_cl]="${_line}${_lines[$((_cl+1))]}"
            _be_splice $((_cl+1)); _mod=1
        fi
    }

    _be_delete_bwd() {
        if (( _cc > 0 )); then
            local _line="${_lines[$_cl]}"
            (( _cc-- ))
            _lines[$_cl]="${_line:0:$_cc}${_line:$((_cc+1))}"
            _mod=1
        elif (( _cl > 0 )); then
            local _pl=${#_lines[$((_cl-1))]}
            _lines[$((_cl-1))]="${_lines[$((_cl-1))]}${_lines[$_cl]}"
            _be_splice "$_cl"
            (( _cl-- )); _cc=$_pl; _mod=1
        fi
        _gcol=-1
    }

    _be_newline() {
        local _before="${_lines[$_cl]:0:$_cc}" _after="${_lines[$_cl]:$_cc}"
        _lines[$_cl]="$_before"
        _be_ins_after "$_cl" "$_after"
        (( _cl++ )); _cc=0; _mod=1; _gcol=-1
    }

    _be_open_line() {
        local _after="${_lines[$_cl]:$_cc}"
        _lines[$_cl]="${_lines[$_cl]:0:$_cc}"
        _be_ins_after "$_cl" "$_after"; _mod=1
    }

    _be_transpose() {
        local _line="${_lines[$_cl]}" _len=${#_lines[$_cl]}
        (( _len < 2 )) && return
        local _p=$_cc
        (( _p >= _len )) && _p=$((_len-1))
        (( _p == 0 )) && _p=1
        local _c1="${_line:$((_p-1)):1}" _c2="${_line:$_p:1}"
        _lines[$_cl]="${_line:0:$((_p-1))}${_c2}${_c1}${_line:$((_p+1))}"
        _cc=$((_p+1)); (( _cc > _len )) && _cc=$_len
        _mod=1; _gcol=-1
    }

    _be_kill_line() {
        local _line="${_lines[$_cl]}" _len=${#_lines[$_cl]}
        if (( _cc < _len )); then
            _kill="${_line:$_cc}"
            _lines[$_cl]="${_line:0:$_cc}"; _mod=1
        elif (( _cl < ${#_lines[@]} - 1 )); then
            _kill=$'\n'
            _lines[$_cl]="${_line}${_lines[$((_cl+1))]}"
            _be_splice $((_cl+1)); _mod=1
        fi
    }

    _be_yank() {
        [[ -z "$_kill" ]] && return
        if [[ "$_kill" == $'\n' ]]; then
            _be_newline; return
        fi
        if [[ "$_kill" != *$'\n'* ]]; then
            local _line="${_lines[$_cl]}"
            _lines[$_cl]="${_line:0:$_cc}${_kill}${_line:$_cc}"
            (( _cc += ${#_kill} )); _mod=1; _gcol=-1; return
        fi
        local -a _parts; local _oi="$IFS" _i
        IFS=$'\n' read -r -d '' -a _parts <<< "$_kill" || true
        IFS="$_oi"
        local _before="${_lines[$_cl]:0:$_cc}" _after="${_lines[$_cl]:$_cc}"
        local _np=${#_parts[@]}
        if (( _np <= 1 )); then
            _lines[$_cl]="${_before}${_parts[0]:-}${_after}"
            (( _cc += ${#_parts[0]:-} )); _mod=1; _gcol=-1; return
        fi
        _lines[$_cl]="${_before}${_parts[0]}"
        for ((_i=1; _i<_np-1; _i++)); do
            _be_ins_after $((_cl+_i-1)) "${_parts[$_i]}"
        done
        _be_ins_after $((_cl+_np-2)) "${_parts[$((_np-1))]}${_after}"
        (( _cl += _np - 1 ))
        _cc=${#_parts[$((_np-1))]}
        _mod=1; _gcol=-1
    }

    _be_fwd_word() {
        local _len=${#_lines[$_cl]}
        while (( _cc < _len )) && [[ "${_lines[$_cl]:$_cc:1}" =~ [^[:alnum:]] ]]; do (( _cc++ )); done
        while (( _cc < _len )) && [[ "${_lines[$_cl]:$_cc:1}" =~ [[:alnum:]] ]]; do (( _cc++ )); done
        _gcol=-1
    }

    _be_bwd_word() {
        (( _cc > 0 )) && (( _cc-- ))
        while (( _cc > 0 )) && [[ "${_lines[$_cl]:$_cc:1}" =~ [^[:alnum:]] ]]; do (( _cc-- )); done
        while (( _cc > 0 )) && [[ "${_lines[$_cl]:$((_cc-1)):1}" =~ [[:alnum:]] ]]; do (( _cc-- )); done
        _gcol=-1
    }

    _be_kill_word() {
        local _start=$_cc _line="${_lines[$_cl]}"
        _be_fwd_word
        _kill="${_line:$_start:$((_cc - _start))}"
        _lines[$_cl]="${_line:0:$_start}${_line:$_cc}"
        _cc=$_start; _mod=1
    }

    _be_kill_word_bwd() {
        local _end=$_cc _line="${_lines[$_cl]}"
        _be_bwd_word
        _kill="${_line:$_cc:$((_end - _cc))}"
        _lines[$_cl]="${_line:0:$_cc}${_line:$_end}"
        _mod=1
    }

    _be_upcase_word() {
        local _line="${_lines[$_cl]}" _s=$_cc
        _be_fwd_word
        local _w="${_line:$_s:$((_cc - _s))}"
        _lines[$_cl]="${_line:0:$_s}${_w^^}${_line:$_cc}"; _mod=1
    }

    _be_downcase_word() {
        local _line="${_lines[$_cl]}" _s=$_cc
        _be_fwd_word
        local _w="${_line:$_s:$((_cc - _s))}"
        _lines[$_cl]="${_line:0:$_s}${_w,,}${_line:$_cc}"; _mod=1
    }

    _be_cap_word() {
        local _line="${_lines[$_cl]}" _s=$_cc
        _be_fwd_word
        local _w="${_line:$_s:$((_cc - _s))}"
        [[ -n "$_w" ]] && _w="${_w,,}" && _w="${_w^}"
        _lines[$_cl]="${_line:0:$_s}${_w}${_line:$_cc}"; _mod=1
    }

    _be_set_mark() {
        _ml=$_cl; _mc=$_cc; _mactive=1; _msg="Mark set"
    }

    _be_xchg_mark() {
        if (( _ml < 0 )); then _msg="No mark set"; return; fi
        local _tl=$_cl _tc=$_cc
        _cl=$_ml; _cc=$_mc; _ml=$_tl; _mc=$_tc
    }

    _be_get_region() {
        if (( _ml < 0 )); then _msg="No mark set"; return 1; fi
        if (( _ml < _cl || (_ml == _cl && _mc < _cc) )); then
            _rsl=$_ml; _rsc=$_mc; _rel=$_cl; _rec=$_cc
        else
            _rsl=$_cl; _rsc=$_cc; _rel=$_ml; _rec=$_mc
        fi
    }

    _be_region_text() {
        local _i _text=""
        if (( _rsl == _rel )); then
            _text="${_lines[$_rsl]:$_rsc:$((_rec - _rsc))}"
        else
            _text="${_lines[$_rsl]:$_rsc}"
            for ((_i=_rsl+1; _i<_rel; _i++)); do _text+=$'\n'"${_lines[$_i]}"; done
            _text+=$'\n'"${_lines[$_rel]:0:$_rec}"
        fi
        printf '%s' "$_text"
    }

    _be_kill_region() {
        local _rsl _rsc _rel _rec
        _be_get_region || return
        _kill="$(_be_region_text)"
        if (( _rsl == _rel )); then
            local _line="${_lines[$_rsl]}"
            _lines[$_rsl]="${_line:0:$_rsc}${_line:$_rec}"
        else
            _lines[$_rsl]="${_lines[$_rsl]:0:$_rsc}${_lines[$_rel]:$_rec}"
            local -a _new=(); local _i
            for ((_i=0; _i<${#_lines[@]}; _i++)); do
                (( _i > _rsl && _i <= _rel )) || _new+=("${_lines[$_i]}")
            done
            _lines=("${_new[@]}")
        fi
        _cl=$_rsl; _cc=$_rsc; _ml=-1; _mactive=0
        _mod=1; _gcol=-1
    }

    _be_copy_region() {
        local _rsl _rsc _rel _rec
        _be_get_region || return
        _kill="$(_be_region_text)"
        _mactive=0; _msg="Region copied"
    }

    _be_read_mini() {
        local _prompt="$1" _default="$2" _result="$_default" _ch _ord
        printf '%s%s;1H%sK%s%s' "$CSI" "$_rows" "$CSI" "$_prompt" "$_result"
        while true; do
            IFS= read -r -s -n1 _ch
            printf -v _ord '%d' "'$_ch" 2>/dev/null || _ord=0
            case $_ord in
                7|27) _msg="Quit"; _mini=""; return 1 ;;
                13|10) _mini="$_result"; return 0 ;;
                127|8)
                    [[ -n "$_result" ]] && _result="${_result:0:$((${#_result}-1))}"
                    printf '%s%s;1H%sK%s%s' "$CSI" "$_rows" "$CSI" "$_prompt" "$_result"
                    ;;
                *)
                    if (( _ord >= 32 )); then
                        _result+="$_ch"
                        printf '%s%s;1H%sK%s%s' "$CSI" "$_rows" "$CSI" "$_prompt" "$_result"
                    fi ;;
            esac
        done
    }

    _be_isearch() {
        local _dir="$1" _srch="" _ch _ord _save_cl=$_cl _save_cc=$_cc
        while true; do
            printf '%s%s;1H%sK' "$CSI" "$_rows" "$CSI"
            [[ "$_dir" == "fwd" ]] && printf 'I-search: %s' "$_srch" \
                                    || printf 'I-search backward: %s' "$_srch"
            IFS= read -r -s -n1 _ch
            printf -v _ord '%d' "'$_ch" 2>/dev/null || _ord=0
            case $_ord in
                7)  _cl=$_save_cl; _cc=$_save_cc; _msg="Quit"; return ;;
                27) return ;;
                13|10) return ;;
                19) _dir="fwd"; (( _cc++ )) ;;
                18) _dir="bwd" ;;
                127|8) [[ ${#_srch} -gt 0 ]] && _srch="${_srch:0:$((${#_srch}-1))}" ;;
                *) (( _ord >= 32 )) && _srch+="$_ch" ;;
            esac
            [[ -z "$_srch" ]] && continue
            local _found=0 _sl _sc _rest _pos
            if [[ "$_dir" == "fwd" ]]; then
                for ((_sl=_cl; _sl<${#_lines[@]}; _sl++)); do
                    _sc=0; (( _sl == _cl )) && _sc=$_cc
                    _rest="${_lines[$_sl]:$_sc}"
                    case "$_rest" in *"$_srch"*)
                        _pos="${_rest%%"$_srch"*}"
                        _cl=$_sl; _cc=$((_sc + ${#_pos})); _found=1; break ;;
                    esac
                done
            else
                local _lp _off _tmp _p
                for ((_sl=_cl; _sl>=0; _sl--)); do
                    _rest="${_lines[$_sl]}"
                    (( _sl == _cl )) && _rest="${_lines[$_sl]:0:$_cc}"
                    _lp=-1; _off=0; _tmp="$_rest"
                    while true; do
                        case "$_tmp" in *"$_srch"*)
                            _p="${_tmp%%"$_srch"*}"
                            _lp=$((_off + ${#_p})); _off=$((_off + ${#_p} + 1))
                            _tmp="${_tmp:$((${#_p}+1))}" ;; *) break ;; esac
                    done
                    if (( _lp >= 0 )); then
                        _cl=$_sl; _cc=$_lp; _found=1; break
                    fi
                done
            fi
            if (( _found )); then
                _be_clamp; _be_draw
            else
                printf '%s%s;1H%sK%s' "$CSI" "$_rows" "$CSI" "Failing I-search: $_srch"
            fi
        done
    }

    _be_query_replace() {
        local _from _to _ch _count=0 _sl _sc _rest _pos _col _line
        _be_read_mini "Query replace: " "" || return
        _from="$_mini"; [[ -z "$_from" ]] && return
        _be_read_mini "with: " "" || return
        _to="$_mini"
        for ((_sl=_cl; _sl<${#_lines[@]}; _sl++)); do
            _sc=0; (( _sl == _cl )) && _sc=$_cc
            while true; do
                _rest="${_lines[$_sl]:$_sc}"
                case "$_rest" in *"$_from"*) ;; *) break ;; esac
                _pos="${_rest%%"$_from"*}"; _col=$((_sc + ${#_pos}))
                _cl=$_sl; _cc=$_col; _be_clamp; _be_draw
                printf '%s%s;1H%sKReplace? (y/n/!/q) ' "$CSI" "$_rows" "$CSI"
                IFS= read -r -s -n1 _ch
                case "$_ch" in
                    y|Y) _line="${_lines[$_sl]}"
                         _lines[$_sl]="${_line:0:$_col}${_to}${_line:$((_col+${#_from}))}"
                         _mod=1; (( _count++ )); _sc=$((_col + ${#_to})) ;;
                    n|N) _sc=$((_col + ${#_from})) ;;
                    '!') while true; do
                            _rest="${_lines[$_sl]:$_sc}"
                            case "$_rest" in *"$_from"*) ;; *) break ;; esac
                            _pos="${_rest%%"$_from"*}"; _col=$((_sc + ${#_pos}))
                            _line="${_lines[$_sl]}"
                            _lines[$_sl]="${_line:0:$_col}${_to}${_line:$((_col+${#_from}))}"
                            _mod=1; (( _count++ )); _sc=$((_col + ${#_to}))
                         done
                         for ((_sl++; _sl<${#_lines[@]}; _sl++)); do
                            _sc=0
                            while true; do
                                _rest="${_lines[$_sl]:$_sc}"
                                case "$_rest" in *"$_from"*) ;; *) break ;; esac
                                _pos="${_rest%%"$_from"*}"; _col=$((_sc + ${#_pos}))
                                _line="${_lines[$_sl]}"
                                _lines[$_sl]="${_line:0:$_col}${_to}${_line:$((_col+${#_from}))}"
                                _mod=1; (( _count++ )); _sc=$((_col + ${#_to}))
                            done
                         done
                         _msg="Replaced $_count occurrences"; return ;;
                    *) _msg="Replaced $_count occurrences"; return ;;
                esac
            done
        done
        _msg="Replaced $_count occurrences"
    }

    _be_find_file() {
        if (( _mod )); then
            printf '%s%s;1H%sKBuffer modified; save first? (y/n) ' "$CSI" "$_rows" "$CSI"
            local _ans; IFS= read -r -s -n1 _ans
            [[ "$_ans" == [yY] ]] && _be_save
        fi
        _be_read_mini "Find file: " "" || return
        [[ -z "$_mini" ]] && return
        _f="$_mini"; _cl=0; _cc=0; _top=0; _left=0
        _ml=-1; _mactive=0; _gcol=-1
        _be_load; _msg="$_f"
    }

    _be_write_file() {
        _be_read_mini "Write file: " "$_f" || return
        [[ -z "$_mini" ]] && return
        _f="$_mini"
        local _i
        { for ((_i=0; _i<${#_lines[@]}; _i++)); do
            printf '%s\n' "${_lines[$_i]}"
        done; } > "$_f"
        _mod=0; _msg="Wrote $_f (${#_lines[@]} lines)"
    }

    _be_insert_file() {
        _be_read_mini "Insert file: " "" || return
        [[ -z "$_mini" || ! -f "$_mini" ]] && { _msg="File not found"; return; }
        local -a _flines=(); local _ln
        while IFS= read -r _ln || [[ -n "$_ln" ]]; do
            _flines+=("${_ln%$'\r'}")
        done < "$_mini"
        (( ${#_flines[@]} == 0 )) && return
        local _after="${_lines[$_cl]:$_cc}" _i
        _lines[$_cl]="${_lines[$_cl]:0:$_cc}${_flines[0]}"
        for ((_i=1; _i<${#_flines[@]}; _i++)); do
            _be_ins_after $((_cl+_i-1)) "${_flines[$_i]}"
        done
        if (( ${#_flines[@]} > 1 )); then
            local _last=$((_cl + ${#_flines[@]} - 1))
            _lines[$_last]="${_lines[$_last]}${_after}"
            _cl=$_last; _cc=${#_lines[$_last]}; (( _cc -= ${#_after} ))
        else
            _lines[$_cl]="${_lines[$_cl]}${_after}"
            _cc=${#_lines[$_cl]}; (( _cc -= ${#_after} ))
        fi
        _mod=1; _msg="Inserted $_mini"
    }

    _be_goto_line() {
        _be_read_mini "Goto line: " "" || return
        if [[ "$_mini" =~ ^[0-9]+$ ]] && (( _mini > 0 )); then
            _cl=$((_mini - 1)); _cc=0; _gcol=-1
        else
            _msg="Invalid line number"
        fi
    }

    _be_recenter() {
        _top=$((_cl - _erows / 2))
        (( _top < 0 )) && _top=0
    }

    _be_what_pos() {
        local _line="${_lines[$_cl]}" _ci
        if (( _cc < ${#_line} )); then
            printf -v _ci 'Char: %s (%d)' "${_line:$_cc:1}" "'${_line:$_cc:1}"
        else _ci="Char: EOL"; fi
        _msg="L$((_cl+1)) C$((_cc+1)) $_ci  (${#_lines[@]} lines in buffer)"
    }

    _be_ask_save() {
        printf '%s%s;1H%sKSave buffer %s? (y/n/C-g) ' "$CSI" "$_rows" "$CSI" "$_f"
        local _ans; IFS= read -r -s -n1 _ans
        case "$_ans" in
            [yY]) _be_save; return 0 ;;
            [nN]) return 0 ;;
            *) _msg="Quit"; return 1 ;;
        esac
    }

    _be_extended_cmd() {
        _be_read_mini "M-x " "" || return
        case "$_mini" in
            goto-line)              _be_goto_line ;;
            query-replace)          _be_query_replace ;;
            what-cursor-position)   _be_what_pos ;;
            save-buffer)            _be_save ;;
            find-file)              _be_find_file ;;
            write-file)             _be_write_file ;;
            insert-file)            _be_insert_file ;;
            kill-buffer)
                _lines=(""); _cl=0; _cc=0; _top=0; _left=0; _mod=0
                _msg="Buffer killed" ;;
            save-buffers-kill-emacs)
                if (( _mod )); then _be_ask_save || return; fi
                _running=0 ;;
            *) _msg="Unknown command: $_mini" ;;
        esac
    }

    # --- Terminal init ---
    trap '_be_cleanup' EXIT
    trap '_resized=1' WINCH

    printf '%s%s' "${CSI}?1049h" "${CSI}2J${CSI}H"
    stty -echo -icanon -isig
    _be_load; _be_clamp; _be_draw

    # --- Main loop ---
    local _ch _seq _csi _ord _len _param

    while (( _running )); do
        if (( _resized )); then
            _resized=0
            _rows=$(tput lines); _cols=$(tput cols); _erows=$((_rows - 2))
            _be_clamp; printf '%s' "${CSI}2J"; _be_draw
        fi

        IFS= read -r -s -n1 _ch
        printf -v _ord '%d' "'$_ch" 2>/dev/null || _ord=0

        # --- Escape sequences ---
        if (( _ord == 27 )); then
            IFS= read -r -s -n1 -t 0.05 _seq || true
            if [[ -z "$_seq" ]]; then
                _cx=0; _msg="Quit"; _be_clamp; _be_draw; continue
            fi
            _cx=0
            if [[ "$_seq" == "[" ]]; then
                IFS= read -r -s -n1 _csi
                if [[ "$_csi" =~ [0-9] ]]; then
                    _param="$_csi"
                    while IFS= read -r -s -n1 -t 0.05 _csi && [[ "$_csi" =~ [0-9\;] ]]; do
                        _param+="$_csi"
                    done
                    case "${_param}${_csi}" in
                        1~|7~)   _cc=0; _gcol=-1 ;;
                        4~|8~)   _cc=${#_lines[$_cl]}; _gcol=-1 ;;
                        3~)      _be_delete_char ;;
                        5~)      (( _cl -= _erows )); (( _top -= _erows ))
                                 (( _top < 0 )) && _top=0 ;;
                        6~)      (( _cl += _erows )); (( _top += _erows )) ;;
                        1\;5C)   _be_fwd_word ;;
                        1\;5D)   _be_bwd_word ;;
                    esac
                else
                    case "$_csi" in
                        A) (( _cl > 0 )) && {
                            (( _gcol < 0 )) && _gcol=$_cc
                            (( _cl-- )); _cc=$_gcol; } ;;
                        B) (( _cl < ${#_lines[@]}-1 )) && {
                            (( _gcol < 0 )) && _gcol=$_cc
                            (( _cl++ )); _cc=$_gcol; } ;;
                        C) _len=${#_lines[$_cl]}
                           if (( _cc < _len )); then (( _cc++ ))
                           elif (( _cl < ${#_lines[@]}-1 )); then (( _cl++ )); _cc=0; fi
                           _gcol=-1 ;;
                        D) if (( _cc > 0 )); then (( _cc-- ))
                           elif (( _cl > 0 )); then (( _cl-- )); _cc=${#_lines[$_cl]}; fi
                           _gcol=-1 ;;
                        H) _cc=0; _gcol=-1 ;;
                        F) _cc=${#_lines[$_cl]}; _gcol=-1 ;;
                    esac
                fi
            elif [[ "$_seq" == "O" ]]; then
                IFS= read -r -s -n1 _csi
                case "$_csi" in
                    H) _cc=0; _gcol=-1 ;;
                    F) _cc=${#_lines[$_cl]}; _gcol=-1 ;;
                esac
            else
                case "$_seq" in
                    f|F)            _be_fwd_word ;;
                    b|B)            _be_bwd_word ;;
                    d|D)            _be_kill_word ;;
                    v|V)            (( _cl -= _erows )); (( _top -= _erows ))
                                    (( _top < 0 )) && _top=0 ;;
                    u|U)            _be_upcase_word ;;
                    l|L)            _be_downcase_word ;;
                    c|C)            _be_cap_word ;;
                    w|W)            _be_copy_region ;;
                    g|G)            _be_goto_line ;;
                    x|X)            _be_extended_cmd ;;
                    '<')            _cl=0; _cc=0; _top=0; _gcol=-1 ;;
                    '>')            _cl=$((${#_lines[@]}-1)); _cc=${#_lines[$_cl]}; _gcol=-1 ;;
                    '%')            _be_query_replace ;;
                    $'\x7f'|$'\x08') _be_kill_word_bwd ;;
                esac
            fi
            _be_clamp; _be_draw; continue
        fi

        # --- C-x prefix ---
        if (( _cx )); then
            _cx=0
            if (( _ord < 32 )); then
                case $_ord in
                    3)  if (( _mod )); then _be_ask_save || { _be_clamp; _be_draw; continue; }; fi
                        _running=0 ;;
                    6)  _be_find_file ;;
                    19) _be_save ;;
                    23) _be_write_file ;;
                    24) _be_xchg_mark ;;
                esac
            else
                case "$_ch" in
                    g) _be_goto_line ;;
                    =) _be_what_pos ;;
                    h) _ml=0; _mc=0; _cl=$((${#_lines[@]}-1)); _cc=${#_lines[$_cl]}
                       _mactive=1; _msg="Mark set" ;;
                    i) _be_insert_file ;;
                    k) _lines=(""); _cl=0; _cc=0; _top=0; _left=0; _mod=0
                       _msg="Buffer killed" ;;
                    *) _msg="C-x $_ch is undefined" ;;
                esac
            fi
            _be_clamp; _be_draw; continue
        fi

        # --- Regular keys ---
        case $_ord in
            0)  if [[ -n "$_ch" ]]; then _be_insert_char "$_ch"
                else _be_set_mark; fi ;;
            1)  _cc=0; _gcol=-1 ;;
            2)  if (( _cc > 0 )); then (( _cc-- ))
                elif (( _cl > 0 )); then (( _cl-- )); _cc=${#_lines[$_cl]}; fi
                _gcol=-1 ;;
            4)  _be_delete_char ;;
            5)  _cc=${#_lines[$_cl]}; _gcol=-1 ;;
            6)  _len=${#_lines[$_cl]}
                if (( _cc < _len )); then (( _cc++ ))
                elif (( _cl < ${#_lines[@]}-1 )); then (( _cl++ )); _cc=0; fi
                _gcol=-1 ;;
            7)  _msg="Quit"; _cx=0 ;;
            8|127) _be_delete_bwd ;;
            9)  _be_insert_char $'\t' ;;
            10|13) _be_newline ;;
            11) _be_kill_line ;;
            12) _be_recenter ;;
            14) if (( _cl < ${#_lines[@]}-1 )); then
                    (( _gcol < 0 )) && _gcol=$_cc
                    (( _cl++ )); _cc=$_gcol; fi ;;
            15) _be_open_line ;;
            16) if (( _cl > 0 )); then
                    (( _gcol < 0 )) && _gcol=$_cc
                    (( _cl-- )); _cc=$_gcol; fi ;;
            18) _be_isearch "bwd" ;;
            19) _be_isearch "fwd" ;;
            20) _be_transpose ;;
            22) (( _cl += _erows )); (( _top += _erows )) ;;
            23) _be_kill_region ;;
            24) _cx=1; _msg="C-x-"; _be_clamp; _be_draw; continue ;;
            25) _be_yank ;;
            26) _be_cleanup; kill -TSTP $$
                printf '%s%s' "${CSI}?1049h" "${CSI}2J"
                stty -echo -icanon -isig
                _rows=$(tput lines); _cols=$(tput cols); _erows=$((_rows - 2)) ;;
            *) (( _ord >= 32 )) && _be_insert_char "$_ch" ;;
        esac

        _be_clamp; _be_draw
    done

    # --- Teardown ---
    trap - EXIT WINCH
    _be_cleanup

    unset -f _be_cleanup _be_load _be_save _be_splice _be_ins_after _be_clamp \
        _be_draw _be_insert_char _be_delete_char _be_delete_bwd _be_newline \
        _be_open_line _be_transpose _be_kill_line _be_yank _be_fwd_word \
        _be_bwd_word _be_kill_word _be_kill_word_bwd _be_upcase_word \
        _be_downcase_word _be_cap_word _be_set_mark _be_xchg_mark \
        _be_get_region _be_region_text _be_kill_region _be_copy_region \
        _be_read_mini _be_isearch _be_query_replace _be_find_file \
        _be_write_file _be_insert_file _be_goto_line _be_recenter \
        _be_what_pos _be_ask_save _be_extended_cmd
}

if [[ "${BASH_SOURCE[0]}" == "${0}" ]]; then
    bademacs "$@"
fi
